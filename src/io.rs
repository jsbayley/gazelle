//! Input/output functionality for structural models

use crate::core::Model;
use crate::error::{GazelleError, Result};
use std::fs::File;
use std::io::{Read, Write};
use std::path::Path;

/// Model file formats
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum FileFormat {
    Json,
    Yaml,
    Custom, // Gazelle's custom format
}

impl FileFormat {
    /// Determine format from file extension
    pub fn from_extension(path: &Path) -> Self {
        match path.extension().and_then(|ext| ext.to_str()) {
            Some("json") => FileFormat::Json,
            Some("yaml") | Some("yml") => FileFormat::Yaml,
            Some("gaz") | Some("gazelle") => FileFormat::Custom,
            _ => FileFormat::Json, // Default
        }
    }
}

/// Model I/O operations
pub struct ModelIO;

impl ModelIO {
    /// Load model from file
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Model> {
        let path = path.as_ref();
        let format = FileFormat::from_extension(path);
        
        let mut file = File::open(path)
            .map_err(|e| GazelleError::IoError(e))?;
        
        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .map_err(|e| GazelleError::IoError(e))?;
        
        Self::parse_model(&contents, format)
    }

    /// Save model to file
    pub fn save_to_file<P: AsRef<Path>>(model: &Model, path: P) -> Result<()> {
        let path = path.as_ref();
        let format = FileFormat::from_extension(path);
        
        let contents = Self::serialize_model(model, format)?;
        
        let mut file = File::create(path)
            .map_err(|e| GazelleError::IoError(e))?;
        
        file.write_all(contents.as_bytes())
            .map_err(|e| GazelleError::IoError(e))?;
        
        Ok(())
    }

    /// Parse model from string
    pub fn parse_model(contents: &str, format: FileFormat) -> Result<Model> {
        match format {
            FileFormat::Json => {
                serde_json::from_str(contents)
                    .map_err(|e| GazelleError::SerializationError(e.to_string()))
            }
            FileFormat::Yaml => {
                serde_yaml::from_str(contents)
                    .map_err(|e| GazelleError::YamlError(e))
            }
            FileFormat::Custom => {
                Self::parse_custom_format(contents)
            }
        }
    }

    /// Serialize model to string
    pub fn serialize_model(model: &Model, format: FileFormat) -> Result<String> {
        match format {
            FileFormat::Json => {
                serde_json::to_string_pretty(model)
                    .map_err(|e| GazelleError::SerializationError(e.to_string()))
            }
            FileFormat::Yaml => {
                serde_yaml::to_string(model)
                    .map_err(|e| GazelleError::YamlError(e))
            }
            FileFormat::Custom => {
                Self::serialize_custom_format(model)
            }
        }
    }

    /// Parse Gazelle's custom format
    fn parse_custom_format(contents: &str) -> Result<Model> {
        let mut model = Model::new();
        let mut current_section = "";
        
        for line in contents.lines() {
            let line = line.trim();
            
            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            
            // Section headers
            if line.starts_with('[') && line.ends_with(']') {
                current_section = &line[1..line.len()-1];
                continue;
            }
            
            match current_section {
                "nodes" => {
                    Self::parse_node_line(line, &mut model)?;
                }
                "materials" => {
                    Self::parse_material_line(line, &mut model)?;
                }
                "elements" => {
                    Self::parse_element_line(line, &mut model)?;
                }
                "loads" => {
                    Self::parse_load_line(line, &mut model)?;
                }
                "constraints" => {
                    Self::parse_constraint_line(line, &mut model)?;
                }
                _ => {
                    // Unknown section, ignore
                }
            }
        }
        
        Ok(model)
    }

    /// Serialize to Gazelle's custom format
    fn serialize_custom_format(model: &Model) -> Result<String> {
        let mut output = String::new();
        
        // Header
        output.push_str("# Gazelle Structural Model\n");
        output.push_str("# Generated by Gazelle Engine\n\n");
        
        // Nodes
        if !model.nodes.is_empty() {
            output.push_str("[nodes]\n");
            output.push_str("# id x y z\n");
            for node in model.nodes.values() {
                output.push_str(&format!("{} {} {} {}\n", 
                    node.id, node.x, node.y, node.z));
            }
            output.push('\n');
        }
        
        // Materials
        if !model.materials.is_empty() {
            output.push_str("[materials]\n");
            output.push_str("# id name type E nu density\n");
            for material in model.materials.values() {
                let e = material.properties.young_modulus.unwrap_or(0.0);
                let nu = material.properties.poisson_ratio.unwrap_or(0.0);
                let rho = material.properties.density.unwrap_or(0.0);
                output.push_str(&format!("{} {} {:?} {} {} {}\n",
                    material.id, material.name, material.material_type, e, nu, rho));
            }
            output.push('\n');
        }
        
        // Elements
        if !model.elements.is_empty() {
            output.push_str("[elements]\n");
            output.push_str("# id type material_id node_ids area\n");
            for element in model.elements.values() {
                let area = element.properties.area.unwrap_or(0.0);
                let nodes_str = element.nodes.iter()
                    .map(|id| id.to_string())
                    .collect::<Vec<_>>()
                    .join(",");
                output.push_str(&format!("{} {:?} {} {} {}\n",
                    element.id, element.element_type, element.material_id, nodes_str, area));
            }
            output.push('\n');
        }
        
        // Loads (simplified)
        if !model.loads.is_empty() {
            output.push_str("[loads]\n");
            output.push_str("# Loads section (simplified representation)\n");
            for (i, _load) in model.loads.iter().enumerate() {
                output.push_str(&format!("# Load {}\n", i));
            }
            output.push('\n');
        }
        
        // Constraints (simplified)
        if !model.constraints.is_empty() {
            output.push_str("[constraints]\n");
            output.push_str("# Constraints section (simplified representation)\n");
            for (i, _constraint) in model.constraints.iter().enumerate() {
                output.push_str(&format!("# Constraint {}\n", i));
            }
            output.push('\n');
        }
        
        Ok(output)
    }

    /// Parse a node line in custom format
    fn parse_node_line(line: &str, model: &mut Model) -> Result<()> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 4 {
            let id: usize = parts[0].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid node ID".to_string())
            })?;
            let x: f64 = parts[1].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid x coordinate".to_string())
            })?;
            let y: f64 = parts[2].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid y coordinate".to_string())
            })?;
            let z: f64 = parts[3].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid z coordinate".to_string())
            })?;
            
            let node = crate::core::Node::new(id, x, y, z);
            model.add_node(node)?;
        }
        Ok(())
    }

    /// Parse a material line in custom format  
    fn parse_material_line(line: &str, model: &mut Model) -> Result<()> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 6 {
            let id: usize = parts[0].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid material ID".to_string())
            })?;
            let name = parts[1].to_string();
            let e: f64 = parts[3].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid Young's modulus".to_string())
            })?;
            let nu: f64 = parts[4].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid Poisson's ratio".to_string())
            })?;
            let rho: f64 = parts[5].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid density".to_string())
            })?;
            
            let material = crate::materials::Material::linear_elastic(id, name, e, nu, rho);
            model.add_material(material)?;
        }
        Ok(())
    }

    /// Parse an element line in custom format
    fn parse_element_line(line: &str, model: &mut Model) -> Result<()> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 5 {
            let id: usize = parts[0].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid element ID".to_string())
            })?;
            
            // Parse element type (simplified)
            let element_type = match parts[1] {
                "Truss2D" => crate::core::ElementType::Truss2D,
                "Truss3D" => crate::core::ElementType::Truss3D,
                "Beam2D" => crate::core::ElementType::Beam2D,
                "Frame3D" => crate::core::ElementType::Frame3D,
                _ => crate::core::ElementType::Truss2D, // Default
            };
            
            let material_id: usize = parts[2].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid material ID".to_string())
            })?;
            
            let nodes: Result<Vec<usize>> = parts[3].split(',')
                .map(|s| s.parse().map_err(|_| {
                    GazelleError::ValidationError("Invalid node ID in element".to_string())
                }))
                .collect();
            let nodes = nodes?;
            
            let area: f64 = parts[4].parse().map_err(|_| {
                GazelleError::ValidationError("Invalid area".to_string())
            })?;
            
            let properties = crate::core::ElementProperties::truss(area);
            let element = crate::core::Element::new(id, element_type, nodes, material_id, properties);
            model.add_element(element)?;
        }
        Ok(())
    }

    /// Parse a load line (placeholder)
    fn parse_load_line(_line: &str, _model: &mut Model) -> Result<()> {
        // TODO: Implement load parsing
        Ok(())
    }

    /// Parse a constraint line (placeholder)
    fn parse_constraint_line(_line: &str, _model: &mut Model) -> Result<()> {
        // TODO: Implement constraint parsing
        Ok(())
    }
}

/// Import utilities for common structural analysis formats
pub struct ImportUtilities;

impl ImportUtilities {
    /// Import from NASTRAN-style input (simplified)
    pub fn import_nastran_style(contents: &str) -> Result<Model> {
        let mut model = Model::new();
        
        for line in contents.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('$') {
                continue;
            }
            
            if line.starts_with("GRID") {
                Self::parse_nastran_grid(line, &mut model)?;
            } else if line.starts_with("CROD") || line.starts_with("CBEAM") {
                Self::parse_nastran_element(line, &mut model)?;
            } else if line.starts_with("MAT1") {
                Self::parse_nastran_material(line, &mut model)?;
            }
        }
        
        Ok(model)
    }

    fn parse_nastran_grid(line: &str, model: &mut Model) -> Result<()> {
        // Simple NASTRAN GRID parsing
        let fields: Vec<&str> = line.split_whitespace().collect();
        if fields.len() >= 5 {
            let id: usize = fields[1].parse().unwrap_or(0);
            let x: f64 = fields[3].parse().unwrap_or(0.0);
            let y: f64 = fields[4].parse().unwrap_or(0.0);
            let z: f64 = if fields.len() > 5 { fields[5].parse().unwrap_or(0.0) } else { 0.0 };
            
            let node = crate::core::Node::new(id, x, y, z);
            model.add_node(node)?;
        }
        Ok(())
    }

    fn parse_nastran_element(line: &str, model: &mut Model) -> Result<()> {
        // Simplified element parsing
        let fields: Vec<&str> = line.split_whitespace().collect();
        if fields.len() >= 5 {
            let id: usize = fields[1].parse().unwrap_or(0);
            let material_id: usize = fields[2].parse().unwrap_or(0);
            let node1: usize = fields[3].parse().unwrap_or(0);
            let node2: usize = fields[4].parse().unwrap_or(0);
            
            let element_type = if line.starts_with("CROD") {
                crate::core::ElementType::Truss3D
            } else {
                crate::core::ElementType::Beam3D
            };
            
            let properties = crate::core::ElementProperties::truss(1.0); // Placeholder
            let element = crate::core::Element::new(
                id,
                element_type,
                vec![node1, node2],
                material_id,
                properties,
            );
            
            // Only add if material exists
            if model.materials.contains_key(&material_id) {
                model.add_element(element)?;
            }
        }
        Ok(())
    }

    fn parse_nastran_material(line: &str, model: &mut Model) -> Result<()> {
        // Simple MAT1 parsing
        let fields: Vec<&str> = line.split_whitespace().collect();
        if fields.len() >= 4 {
            let id: usize = fields[1].parse().unwrap_or(0);
            let e: f64 = fields[2].parse().unwrap_or(200e9);
            let nu: f64 = fields[4].parse().unwrap_or(0.3);
            
            let material = crate::materials::Material::linear_elastic(
                id,
                format!("Material_{}", id),
                e,
                nu,
                7850.0, // Default steel density
            );
            model.add_material(material)?;
        }
        Ok(())
    }
}

/// Export utilities for various formats
pub struct ExportUtilities;

impl ExportUtilities {
    /// Export model for visualization (simplified VTK format)
    pub fn export_vtk(model: &Model) -> Result<String> {
        let mut output = String::new();
        
        // VTK header
        output.push_str("# vtk DataFile Version 3.0\n");
        output.push_str("Gazelle Structural Model\n");
        output.push_str("ASCII\n");
        output.push_str("DATASET UNSTRUCTURED_GRID\n\n");
        
        // Points (nodes)
        output.push_str(&format!("POINTS {} float\n", model.nodes.len()));
        for node in model.nodes.values() {
            output.push_str(&format!("{} {} {}\n", node.x, node.y, node.z));
        }
        output.push('\n');
        
        // Cells (elements)
        let total_connectivity: usize = model.elements.values()
            .map(|e| e.nodes.len() + 1)
            .sum();
        
        output.push_str(&format!("CELLS {} {}\n", model.elements.len(), total_connectivity));
        for element in model.elements.values() {
            output.push_str(&format!("{}", element.nodes.len()));
            for &node_id in &element.nodes {
                output.push_str(&format!(" {}", node_id));
            }
            output.push('\n');
        }
        output.push('\n');
        
        // Cell types
        output.push_str(&format!("CELL_TYPES {}\n", model.elements.len()));
        for element in model.elements.values() {
            let vtk_type = match element.element_type {
                crate::core::ElementType::Truss2D | crate::core::ElementType::Truss3D => 3, // VTK_LINE
                crate::core::ElementType::Beam2D | crate::core::ElementType::Beam3D => 3,   // VTK_LINE
                crate::core::ElementType::Frame2D | crate::core::ElementType::Frame3D => 3, // VTK_LINE
                _ => 3, // Default to line
            };
            output.push_str(&format!("{}\n", vtk_type));
        }
        
        Ok(output)
    }

    /// Export results for visualization
    pub fn export_results_vtk(model: &Model, results: &crate::core::AnalysisResults) -> Result<String> {
        let mut output = Self::export_vtk(model)?;
        
        // Add displacement data
        output.push_str(&format!("\nPOINT_DATA {}\n", model.nodes.len()));
        output.push_str("VECTORS displacement float\n");
        
        for node in model.nodes.values() {
            let base_dof = node.id * 6;
            let ux = results.displacements.get(base_dof).unwrap_or(&0.0);
            let uy = results.displacements.get(base_dof + 1).unwrap_or(&0.0);
            let uz = results.displacements.get(base_dof + 2).unwrap_or(&0.0);
            output.push_str(&format!("{} {} {}\n", ux, uy, uz));
        }
        
        // Add displacement magnitude
        output.push_str("SCALARS displacement_magnitude float\n");
        output.push_str("LOOKUP_TABLE default\n");
        
        for node in model.nodes.values() {
            let base_dof = node.id * 6;
            let ux = results.displacements.get(base_dof).unwrap_or(&0.0);
            let uy = results.displacements.get(base_dof + 1).unwrap_or(&0.0);
            let uz = results.displacements.get(base_dof + 2).unwrap_or(&0.0);
            let magnitude = (ux * ux + uy * uy + uz * uz).sqrt();
            output.push_str(&format!("{}\n", magnitude));
        }
        
        Ok(output)
    }
}